<!DOCTYPE html>
<html>
<head>
<style>
/* Add basic CSS styles if needed, e.g., to position the divs correctly */
</style>
</head>
<body>


<img hidden=true src="pod.png" id="pod">

<img hidden=true src="a2.png" id="rock1">
<img hidden=true src="p2.png" id="p1">
<img hidden=true src="p1.png" id="p2">
<img hidden=true src="sun.png" id="sunSprite">
<img hidden=true src="t1.png" id="t1">
<img hidden=true src="t2.png" id="t2">
<img hidden=true src="t3.png" id="t3">
<img hidden=true src="t4.png" id="t4">
<img hidden=true src="t5.png" id="t5">
<img hidden=true src="p3.png" id="p3">
<img hidden=true src="p4.png" id="p4">
<img hidden=true src="freighter.png" id="freightSprite">
<img hidden=true src="fighter.png" id="fighterSprite">
<img hidden=true src="component.png" id="compSprite">


<!-- North Wall (Far Wall) -->

<div class="tiled-backgroundf" id="sky" style=" background-image: url('stars.png'); 
    background-repeat: repeat; 
    min-height: 100vh; 
    border: 0px;
    background-position: 5px 0px;
	position: fixed; /* Fixes them to the viewport */
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
	 background-Size: 1000px 1000px;
	 filter: bloom(10);" >
</div>

<canvas id="visuals" width="100" height="100" style="position:absolute;top:0%;left:0%;border:0px solid;border-color:#0f0f0f;z-index:5" ></canvas>
<div style="position:absolute;background-color:#b3b3b3;z-index:6;width:175px;height:300px;top:50%;left:50%;border-style:inset;overflow:auto;"id="sysMenu">
</div>
<div style="position:absolute;background-color:#b3b3b3;z-index:7;width:175px;height:300px;top:50%;left:50%;border-style:inset;overflow:auto;"id="sysSelectBox">
<img src="power.png"id="powerSwitch" width=25 >
<img src="jettison.png" width=25 id="jettisonSwitch"> 
<img src="repair.png"style="width:25px"id="repairButton">
<div id="powerMeter">

</div>

<script>
// --- Global Variables (FIXED) ---
var canvas = document.getElementById('visuals');
var ctx = canvas.getContext("2d");
var debug=false
var selectedTile = [0,0]
var rock1 = document.getElementById("rock1")

var gFree = document.getElementById("gFree")

  const audImpact1 = new Audio("oddioimpct2.ogg")
  const audEngine = new Audio("thruster2.ogg")
  const audBoom = new Audio("boom1.ogg")
  const audAlarm = new Audio("alarm.ogg")
  const audAlarm2 = new Audio("alarm2.ogg")
  audEngine.loop = true


var gHold = document.getElementById("gHold")
var dronesprite = document.getElementById("pod")
var ticksUntilBoom=-10
var wd=false
var sd=false
var pd=false
var od=false
var bd=false
var td=false
var c0 = document.getElementById("c0")
var c1 = document.getElementById("c1")
var c2 = document.getElementById("c2")
var c3 = document.getElementById("c3")
var c4 = document.getElementById("c4")
var c5 = document.getElementById("c5")
var t1 = document.getElementById("t1")
var t2 = document.getElementById("t2")
var t3 = document.getElementById("t3")
var t4 = document.getElementById("t4")
var p4 = document.getElementById("p4")
var compSprite = document.getElementById("compSprite")
var freightSprite = document.getElementById("freightSprite")
//var t4 = document.getElementById("t4")
// Add new wall references:


var newPosX = 0
var newPosY = 0
var ukp = false
var collided=false
var speedDiff=0
var speed=0
var driving=true
var off=Math.PI*-2
var dkp = false
var power=1000
var gt=0
var heat=1
var rkp = false
var zd = false
var hunger = 1000000
var spin = 0
var lkp = false
var ox = 0
var oy = 0
var hoff=0
var ox3 = 0
var zoom=5
var colliding = false
var commandedSpeed=0
var selectedTile = [0,0]
var oy3 = 0
var ox2 = 0
var sizeoff=1
var oy2 = 0
var cc = gFree
var boxTop = document.getElementById("BoxTop")
var boxSide = document.getElementById("BoxSide")
var mouseX; 
var mouseY; 
var mx = 0;
var my = 0;
var interacted=false
var smoothX = 0;
var smoothY = 0;
var cwidth=canvas.innerWidth
var cheight=canvas.innerHeight
var curr2
var xo
var drone = {x:50,y:0,t:0,w:32,h:32,r:0,hp:100}
var turnSpeed=0
var mode = "None"
var yo
var x
var y
var pmode=false
var ad=false
var trueTurn=0
var ed=false
var rd = false
var dying=false
var sx=0
var sy=0
var seconds=0
var qd=false
function resetSys(sys) {
return{engine:{dam:0,on:true,des:"Engine",heat:0,eff:100,maxHeat:500,insulation:10,pwrUsg:-250,minHeat:-100,missing:false,dmgRes:1},cooling:{dam:0,on:true,des:"Cooling System",heat:0,eff:100,maxHeat:150,insulation:0,pwrUsg:50,minHeat:-100,missing:false,dmgRes:1},tank:{dam:0,on:true,des:"Plasma Tank",heat:0,eff:100,maxHeat:125,insulation:0,pwrUsg:0,minHeat:-100,missing:false,dmgRes:1},gyroscope:{dam:0,on:true,des:"Gyroscope",heat:0,eff:100,maxHeat:200,insulation:0,pwrUsg:35,minHeat:-100,missing:false,dmgRes:7},sideThrust:{dam:0,on:true,des:"Side Thrusters",heat:0,eff:100,maxHeat:1000,insulation:10,pwrUsg:25,minHeat:-100,missing:false,dmgRes:1},thruster:{dam:0,on:true,des:"Main Thrusters",heat:0,eff:100,maxHeat:1000,insulation:10,pwrUsg:50,minHeat:-100,missing:false,dmgRes:1},shipComputer:{dam:0,on:true,des:"Ship Computer",heat:0,eff:100,maxHeat:125,insulation:5,pwrUsg:15,minHeat:-200,missing:false,dmgRes:1}}
}

var systems=resetSys()
function giveDamage(amnt) {

sysList=Object.values(systems);
slen=sysList.length-1
sysSelect=sysList[random(0,slen)]
console.log(sysSelect,random(0,slen),slen)
sysSelect.dam+=amnt/sysSelect.dmgRes

}
var gyro=systems.Gyroscope
var prevDir=0
var alarmPlayed = false
var sky =document.getElementById("sky")
var dd=false
var GRID_SIZE = 32
var repairButton = document.getElementById("repairButton")
const easingAmount = 0.05; 
canvas.width = window.innerWidth * 1
canvas.height = window.innerHeight * 1
var w = canvas.width;
var h = canvas.height;
const sysMenu = document.getElementById("sysMenu")
const sysBox = document.getElementById("sysSelectBox")
sysBox.style.left = `${(175)}px`; 
sysBox.style.top = `${(0)}px`; 
sysBox.hidden = true
sysMenu.style.left = `${(0)}px`; 
sysMenu.style.top = `${(0)}px`; 
sysMenu.hidden = true
const canvasCenterX = canvas.width / 2;
const canvasCenterY = canvas.height / 2;
function radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
}
function movedir(x,y,dir,amnt) {
return {x:(Math.sin((dir*-1) * Math.PI/180)*Math.round(amnt*100)/100),y:Math.cos((dir*-1) * Math.PI/180)}
}
function checkCircle(c1, c2) {
     dist = Math.hypot(c1.x - c2.x, c1.y - c2.y)

    minDist = (c1.r/3) + (c2.r/2)

    return dist <= minDist
}


//make list of all the systems so we can.. do stuff with it man idk
sysButtons=[]
var lastPressed
var partSelected
for (i in systems) {
newDiv = document.createElement('div')
sysMenu.appendChild(newDiv)
newButt = document.createElement('button');
newDiv.appendChild(newButt)
newButt.textContent=systems[i].des
sysButtons.push(newButt)
newText=document.createElement('body')
newDiv.appendChild(newText)
systems[i].menuStats=newText
newButt.systemRef=i
lastPressed=newButt
partSelected=i
console.log(systems[i])
newButt.style.backgroundColor = "lightgrey";
newButt.addEventListener('click', (evnt) => {

src=evnt.srcElement

lastPressed.style.backgroundColor = "lightgrey";
src.style.backgroundColor = "lightblue";
lastPressed=src
partSelected=systems[src.systemRef]
console.log("WHAT"+partSelected)
});

}
var powerSwitch=document.getElementById("powerSwitch")
var powerMeter = document.getElementById("powerMeter")
console.log(powerSwitch)
powerSwitch.addEventListener('click', (evnt) => {
console.log(partSelected)
partSelected.on=!partSelected.on
});
var jettisonSwitch=document.getElementById("jettisonSwitch")
jettisonSwitch.addEventListener('click', (evnt) => {
console.log(partSelected)
partSelected.missing=true
//shit it out
entities.push({x:drone.x,y:drone.y,w:16,h:16,sprite:compSprite,dist:1,type:"jettisoned",sx:sx,sy:sy,t:0,r:1})
})
repairButton.addEventListener('click', (evnt) => {
partSelected.dam=Math.max(0,partSelected.dam-random(10,50))
})
var entities = [{x:75,y:97,w:150,h:150,sprite:p3,dist:9,type:"Planet",sx:0,sy:0,t:0,r:64,grav:100},{x:100000,y:97,w:10000,h:10000,sprite:p4,dist:1,type:"bigMan",sx:0,sy:0,t:0,r:10000/1.4,grav:1000},{x:10,y:30,w:64,h:64,sprite:rock1,dist:1,type:"Rok",sx:0,sy:0,t:0,r:64},
{x:0,y:0,w:32,h:32,sprite:rock1,dist:1,type:"astroid",t:0,sx:0,sy:0,r:32},{x:300,y:200,w:64,h:64,sprite:freightSprite,dist:1,type:"freighter",t:0,sx:0,sy:0,t:0,r:64}]
var usedPositions = [{x:stg(w / 2 ),y:stg(h / 2)}]
function getDist(x1,y1,x2,y2) {
//console.log(x2,x1)
    const deltaX = x2 - x1;
    const deltaY = y2 - y1;

    // Use the Pythagorean theorem: distance = sqrt((x2 - x1)^2 + (y2 - y1)^2)
    const distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));

    return distance;
}
document.addEventListener('mousemove', (event) => {
  mouseX = event.clientX;
  mouseY = event.clientY;
  mx = event.clientX;
  my = event.clientY;
});
function random(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function pointAt(startX, startY, targetX, targetY,o) {
if(!o){
o=0
}
return Math.atan2(startX-targetX,startY-targetY)+o
}
function calcDist(x1,y1,x2,y2) {
dx = x2 - x1
dy = y2 - y1
return Math.sqrt(dx * dx + dy * dy)
}

function smr32g() {
return random(-1,1) * 32

}
function randSign() {
return Math.sign(Math.random()-0.5)
}
function diff(a,b) {
return(a-b)
}


function mr32g() {
return {x:smr32g(),y:smr32g()}
}
function collideCheck(s1, s2) {
//s1 should always be the player.
px=s1.x 
py=s1.y 
 
  if (px > s2.x-s2.w/2 && px < (s2.x+s2.w/2) && py > s2.y-s2.h/2 && py < (s2.y+s2.h/2) ){
		
    
	 // push the player back the targets width / 2
    return true;
  } else {

  return false;
}
}
 document.addEventListener('keyup', function(event) {
 kc = event.keyCode
 if (kc == 68) {

			dd=false
			
		  }
		  		  if (kc == 65) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ad=false
			
		  }
		  		  		  if (kc == 87) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			wd=false
			
		  }
		  		  		  		  if (kc == 83) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			sd=false
			
		  }
		  		  		  		  if (kc == 81) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			qd=false
			
		  }
		  	  		  		  if (kc == 69) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ed=false
			
		  }
		  	  		  	if (kc == 82) {

			rd=false
			
		  }
		  		  	  		  	if (kc == 79) {

			pd=false
			
		  }
		  		  	  		  	if (kc == 80) {

			od=false
			
		  }
		  		  		  		  		  		  if (kc == 90) {
			
			zd=false
			
		  }
		  		  		  		  	  		  	if (kc == 86) {

			bd=false
			
		  }
		  		  	  		  	if (kc == 84) {

			td=false
			
		  }
 })

    document.addEventListener('keydown', function(event) {
		interacted=true
       kc = event.keyCode
		  console.log(kc)

		  		  	if (kc == 68) {

			dd=true
			
		  }
		  	  		  	if (kc == 82) {

			rd=true
			
		  }
		  		  		  	  		  	if (kc == 79) {

			pd=true
			
		  }
		  		  	  		  	if (kc == 80) {

			od=true
			
		  }
		  		  		  	  		  	if (kc == 86) {

			bd=true
			
		  }
		  		  	  		  	if (kc == 84) {

			td=true
			
		  }
		  		
		  		
		  		  if (kc == 65) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ad=true
			
		  }
		  		  		  if (kc == 81) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			qd=true
			
		  }
		  	  		  		  if (kc == 69) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ed=true
			
		  }
		  		  	  		  		  if (kc == 192) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			debug=!debug
			
		  }
		  		  if (kc == 70) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			mode="Feed"
			
		  }
		  		  		  		  if (kc == 87) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			wd=true
			
		  }
		  		  		  		  if (kc == 83) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			sd=true
			
		  }
		  		  		  		  		  if (kc == 83) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			sd=true
			
		  }
		  		  		  		  		  if (kc == 90) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			zd=true
			
			pmode=!pmode
		  }
		  		  		  		  		  		  if (kc == 71) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			
			
			sysMenu.hidden=!sysMenu.hidden
			sysBox.hidden=!sysBox.hidden
		  }
		 
				

			
		  //try using list like mathematical thingys to sort distances
    });
	 var crashSpin=0
function tick() {
sky.style.backgroundPosition = `${-drone.x/10+hoff}px ${-drone.y/10+hoff}px`;
colliding=false
ticksUntilBoom-=1
if(ticksUntilBoom==0) {
	drone.x=50
drone.y=0
sx=0
sy=0
speed=0
drone.t=0
turnSpeed=0
trueTurn=0
alarmPlayed=false
drone.hp=100
audBoom.play()
audAlarm2.loop=false
for (i4 in systems) {
curr=systems[i4]
curr.dam=0
curr.heat=20
curr.eff=100
}
}
//are we dying?



	

dying=(ticksUntilBoom>0)
totalVelocity= Math.abs(sx+sy)
	 if (od) {
zoom=zoom*1.01
}
if (pd) {
zoom=zoom*0.99
}
zoom=Math.max(0,zoom)
	 ctx.save()
	  
	 ctx.translate(w/2,h/2)
    ctx.scale(zoom,zoom)
	 
	ox = drone.x - canvas.width / 2;
    oy = drone.y - canvas.height / 2;
seconds = Math.floor(gt/100)

    
	 
    setTimeout(() => { 
        ctx.clearRect(-100000,-100000,w*1000,h*1000)
		  const newPosX = ((smoothX - (w / 2)) * -0.025)/zoom
        const newPosY = ((smoothY - (h / 2)) * -0.04)/zoom
        ctx.save()
		  
			
		 	
		  	osx=sx
			osy=sy
		    for (i in entities) {
            curr = entities[i]
						
				ctx.save()


if (curr.type=="bigMan"){
curr.t+=0.01
//curr.sx=(Math.sin((curr.t/10) * Math.PI/-180))
//curr.sy=(Math.cos((curr.t/10) * Math.PI/-180))

gravDir=pointAt(drone.x,drone.y,curr.x,curr.y)
distance=getDist(drone.x,drone.y,curr.x,curr.y)
if (distance<curr.r*2.5) {
sx+=(Math.sin(gravDir)*(curr.grav)/(distance*-100))
sy+=(Math.cos(gravDir)*(curr.grav)/(distance*-100))
}
}
if (curr.type=="jettisoned") {
curr.t+=curr.ts
}
if (curr.type=="astroid"){
curr.t+=0.01
//curr.sx+=0.001
}
if (curr.type=="freighter") {
curr.sx=(Math.sin((curr.t) * Math.PI/-180))
curr.sy=(Math.cos((curr.t) * Math.PI/-180))

curr.t+=1
}
// collision check
if(checkCircle(drone, curr)&&curr.dist==1){

colliding=true
collided=true

aDir=pointAt(curr.x,curr.y,drone.x,drone.y)+Math.PI*-1

prevDir=aDir
// do you know how fast you were going back there?
relativeSpeed = Math.abs(((sx/2)+(sy/2))-((curr.sx/2)+(curr.sy/2)))*5
console.log(relativeSpeed)
if(relativeSpeed>1){
giveDamage(relativeSpeed*10)
// this will not do anything unless we are actively in the middle of dying.
if(ticksUntilBoom>0){
console.log("you now have:",Math.max(0,ticksUntilBoom-(relativeSpeed*25)))
ticksUntilBoom=Math.max(0,ticksUntilBoom-(relativeSpeed*25))
}

}
drone.x=curr.x+(Math.sin((aDir)))*(curr.r/2)
drone.y=curr.y+(Math.cos((aDir)))*(curr.r/2)
//-drone.r/4
sx-=(sx-curr.sx)/25
sy-=(sy-curr.sy)/25

//sx=+((Math.sin((aDir)))*relativeSpeed)/1000
//sy=+((Math.cos((aDir)))*relativeSpeed)/1000

//+(Math.cos((aDir)))*(curr.r/2))/25
//add the turn into this please or else itll be occasionally wrong
turnDisruption=+(((Math.sin(aDir)-0.5)*2)+((Math.cos(aDir)-0.5)*-2))/10
//console.log(turnDisruption)
//turnSpeed+=turnDisruption
//console.log(aDir,sx)
if (interacted) {
audImpact1.volume = Math.min(1,relativeSpeed/3)
audImpact1.play()
}


}




			 ctx.translate((curr.x-drone.x)/curr.dist,(curr.y-drone.y)/curr.dist)
			 ctx.rotate(curr.t * Math.PI/180)
				//ctx.translate((curr.h/off),(curr.h/off))
			 

			   
				ctx.drawImage(curr.sprite,-curr.w/2,-curr.h/2,curr.w,curr.h)
				if(debug&&curr.dist==1){
				ctx.fillStyle="Red"
				ctx.lineWidth = 1;
				ctx.strokeStyle="Red"
				cwi=(curr.w)
				chi=(curr.h)
				cxi=curr.x-curr.w/2
				cyi=curr.y-curr.h/2
				ctx.beginPath()
				ctx.arc(0, 0, curr.r/2, 0, 2 * Math.PI, false);
				ctx.stroke()
				ctx.fill()
				ctx.closePath()
				
				//console.log((w/2)+(Math.sin((prevDir))))


				

				}	
				
if(colliding&&debug){
ctx.fillStyle="blue"
ctx.fillRect(-2,-2,4,4)
}
          curr.x+=curr.sx
			 curr.y+=curr.sy
				ctx.restore()

				//console.log(Math.round(curr.x + drone.x),Math.round(curr.y + drone.y))
				
}
ctx.restore()
// Ensure 'random' is a defined function, e.g., using Math.floor(Math.random() * 101)
const rng = random(0, 10000); 
const GRID_SIZE = 32; // Define the grid size



	 		   



			  ctx.restore()
			  if(debug){
			ctx.fillStyle="Green"
ctx.fillRect((w/2)+(Math.sin((prevDir))*20)-5,(h/2)+(Math.cos((prevDir))*20)-5,10,10)
			
				ctx.fillStyle="Red"
				ctx.lineWidth = 1;
				ctx.strokeStyle="Red"

				ctx.beginPath()
				ctx.arc(w/2, h/2, drone.r, 0, 2 * Math.PI, false);
				ctx.stroke()
				ctx.fill()
				ctx.closePath()
			  }
            ctx.save()
        if (driving) {
		  if (dd) {
		               							if(pmode){
							sx+=0.001
							}else{
         turnSpeed+= (0.025+Math.abs(speed*2))*(gyro.eff/100)
				}
				}
				if (qd) { 
sx=sx+ ((Math.sin(((trueTurn*-1)+90) * Math.PI/180))/175)
sy=sy+  ((Math.cos(((trueTurn*-1)+90) * Math.PI/180))/175)
				}
								if (ed) { 
sx=sx+ ((Math.sin(((trueTurn*-1)-90) * Math.PI/180))/175)
sy=sy+  ((Math.cos(((trueTurn*-1)-90) * Math.PI/180))/175)
				}
					   if (ad) {
						             							if(pmode){
							sx-=0.001
							}else{
             turnSpeed -= (0.025+Math.abs(speed*2))*(gyro.eff/100)
				 }
				}
//					  if (zd) {
//		hoff+=0.1
//					  }
				 		   if (wd) {
              							if(pmode){
							sy-=0.001
							}else{
           commandedSpeed=commandedSpeed+0.00085
			  }
				}
							if (sd) {
							if(pmode){
							sy+=0.001
							}else{
           commandedSpeed=commandedSpeed-0.00085
			  }
				}
				if(rd) {
				//brakes, (slow the FUCK DOWN WE'RE GONNA CRASH!!!!!!!)
 speed=speed/1.0005
 //dir+awaydir/2 -- just curious what something like that would do, try something like that later.
 sx=sx/1.01
sy=sy/1.01
turnSpeed=turnSpeed/(1+(0.1*(gyro.eff/100)))
console.log((1+(0.1*(gyro.eff/100))))
				} 
				shipSystems()
				 heat+= speed*1000
				 heat=(heat/1.01)-0.1
				 heat=Math.min(Math.max(1,heat),50)
				 turnSpeed=(turnSpeed)/(1+(0.02*(gyro.eff/100)))
			 	 speed=speed/1.1
				 commandedSpeed=commandedSpeed/1.1
				 trueTurn = trueTurn-(trueTurn-drone.t)/10
sx=sx+ (Math.sin((trueTurn*-1) * Math.PI/180)*(speed)/1)
sy=sy+  (Math.cos((trueTurn*-1) * Math.PI/180)*(speed)/1)
}
drone.t += turnSpeed
drone.x += sx
drone.y += sy

				
				//offsets=movedir(0,0,trueTurn,speed*100) 
offsets=[0,0]
				//console.log(offsets)
				ctx.translate(w/2-offsets[0], h/2-offsets[1]);
		
    ctx.scale(zoom/10,zoom/10)
ctx.rotate(trueTurn* (Math.PI/180))

    
    

				
				ctx.drawImage(dronesprite,-64,-64,128,128)
				sizeoff=random(0,4)
				sizeoff2=random(-1*(speed*1000)/8,1*(speed*1000)/8)
				audEngine.playbackRate = Math.abs(0.1+Math.ceil(speed*1000))
				if(speed<0.001) {
				timg=t1
				}
				if(speed>0.001) {
				timg=t2
				}
								if(speed>0.002) {
				timg=t3
				}
												if(speed>0.004) {
				timg=t4
				}

					//gah = 90-(Math.sin(gt/10))*-10
					gah = 50+Math.abs(heat)
				ctx.filter = `brightness(${gah}%)`
				ctx.drawImage(timg,-12+sizeoff2,-48-((speed*2000)+sizeoff),24,24+(speed*2000)+sizeoff)
				
				ctx.filter = ``
				ctx.restore();
				
		
//add induvisual systems control--done!--why do i still have this i did it allready a while ago..
			gt+=1
			//console.log(speedDiff)
			//making sure the cooldown is reset
			if (colliding){
			collided=true
			}else{
			collided=false
			}
			
			speedDiff=Math.abs((sx-osx)+(sy-osy))
        tick() 
    }, 10);
}
 function stg(thing) {
return Math.round(thing / 32) * 32
 }

//TODO:
//add power system, (engine generates power) and different systems will use it.--also done.

 function shipSystems() {
 
 engine=systems.engine
 fthrust=systems.thruster
 sthrust=systems.sidethruster
 cooler=systems.cooling
 gyro=systems.gyroscope
fuelTank=systems.tank
computer=systems.shipComputer
 cpsg=0
 
 //how's our engine doing?
 // give it alittle boost if your kind

engine.heat+=0.1+(Math.abs(commandedSpeed/100)*engine.eff)*10
engine.pwrUsg=-1*Math.abs(250/100)*engine.eff
 speed=(commandedSpeed/100)*fthrust.eff


 //cooler can do its thing., if it isnt on, make it cool mutch slower.
avrgHeat=20
heatProbe=[]
for (i3 in systems) {
 heatProbe.push(systems[i3].heat)
}
  
  avrgHeat=1*Math.abs(heatProbe.reduce((a, b) => a + b, 0)/heatProbe.length)
 for (i2 in systems) {
 
curr=systems[i2]
//remove when you add dying from things like the fueltanks exploding


//is this even IN the ship??

if (!curr.missing) {
if(curr==fthrust){
curr.pwrUsg=10+speed*1000
}
if(curr==gyro){
curr.pwrUsg=10+Math.abs(turnSpeed*10)
}
if(curr.heat>curr.maxHeat) {
curr.dam +=0.1

}
if(curr==engine){



engine.eff=Math.max(100-engine.dam,0)
//cpsg-=(engine.eff+((1000-power))/10)
//+Math.sin((gt/100)+random(-1,1))*2
}else {curr.eff=Math.max(((100-curr.dam)/100)*(power/10),0)}
if (!curr.on||curr.missing){curr.eff=0} else {cpsg+=curr.pwrUsg*(curr.eff/1)}

 if (computer.eff!==0) {
 systems[i2].menuStats.innerText= String(Math.floor(systems[i2].heat))+"C; Eff: "+ String(Math.floor(systems[i2].eff))+"%; "+"enabled: "+String(systems[i2].on)
 } else {
  systems[i2].menuStats.innerText= String(Math.floor(random(100,999))+"C; Eff: "+ String(random(100,999))+"%; "+"enabled: "+String("????"))
 }
 //special sysStat texts
 //engine meltdown
 if(curr==engine&&curr.heat>curr.maxHeat){systems[i2].menuStats.innerText="[!Meltdown!] "+systems[i2].menuStats.innerText}
 //gastank explosion
if(curr==fuelTank&&curr.heat>curr.maxHeat&&curr.dam>60){systems[i2].menuStats.innerText="[!Critical!] "+systems[i2].menuStats.innerText}
 
 curr.heat-=(curr.heat-avrgHeat)/500
 curr.heat-=(curr.heat-0)/5000
  if (cooler.on) {
  //check if the cooler is badly damaged, but not completely.
  if ( cooler.dam>80&&cooler.dam<0) {systems[i2].heat-=1} else {
systems[i2].heat+=((20-curr.heat)/1000)*(cooler.eff/100)

}
} else {
systems[i2].heat+=(20-systems[i2].heat)/10000

}

//console.log(systems[i].heat)
} else {curr.eff=0; curr.menuStats.innerText= String("Missing!")}
 }
power=Math.max(Math.min((power-((cpsg/1000))),1000),0)
 
//systems[i2].gyroscope

powerMeter.innerText=String(Math.round(power/10))+"%; "+String(Math.round(-cpsg))+"W;" 

//Condition: "+String(Math.round(100-partSelected.dam))+"%"
 }

tick(); 
</script>

</body>
</html>
