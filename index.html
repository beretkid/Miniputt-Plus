<!DOCTYPE html>
<html>
<head>
<style>
/* Add basic CSS styles if needed, e.g., to position the divs correctly */
</style>
</head>
<body>


<img hidden=true src="pod.png" id="pod">

<img hidden=true src="a2.png" id="rock1">
<img hidden=true src="p2.png" id="p1">
<img hidden=true src="p1.png" id="p2">
<img hidden=true src="sun.png" id="sunSprite">
<img hidden=true src="t1.png" id="t1">
<img hidden=true src="t2.png" id="t2">
<img hidden=true src="t3.png" id="t3">
<img hidden=true src="t4.png" id="t4">
<img hidden=true src="t5.png" id="t5">
<img hidden=true src="p3.png" id="p3">
<img hidden=true src="p4.png" id="p4">
<img hidden=true src="freighter.png" id="freightSprite">
<img hidden=true src="fighter.png" id="fighterSprite">
<img hidden=true src="dashright" id="rightdash">
<!-- North Wall (Far Wall) -->

<div class="tiled-backgroundf" id="sky" style=" background-image: url('stars.png'); 
    background-repeat: repeat; 
    min-height: 100vh; 
    border: 0px;
    background-position: 5px 0px;
	position: fixed; /* Fixes them to the viewport */
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
	 background-Size: 1000px 1000px;
	 filter: bloom(10);" >
</div>

<canvas id="visuals" width="100" height="100" style="position:absolute;top:0%;left:0%;border:0px solid;border-color:#0f0f0f;z-index:5" ></canvas>

<script>
// --- Global Variables (FIXED) ---
var canvas = document.getElementById('visuals');
var ctx = canvas.getContext("2d");
var debug=false
var selectedTile = [0,0]
var rock1 = document.getElementById("rock1")

var gFree = document.getElementById("gFree")

  const audImpact1 = new Audio("oddioimpct2.ogg")
  const audEngine = new Audio("thruster2.ogg")
  const audBoom = new Audio("boom1.ogg")
  const audAlarm = new Audio("alarm.ogg")
  const audAlarm2 = new Audio("alarm2.ogg")
  audEngine.loop = true


var gHold = document.getElementById("gHold")
var dronesprite = document.getElementById("pod")
var ticksUntilBoom=-10
var wd=false
var sd=false
var pd=false
var od=false
var bd=false
var td=false
var c0 = document.getElementById("c0")
var c1 = document.getElementById("c1")
var c2 = document.getElementById("c2")
var c3 = document.getElementById("c3")
var c4 = document.getElementById("c4")
var c5 = document.getElementById("c5")
var t1 = document.getElementById("t1")
var t2 = document.getElementById("t2")
var t3 = document.getElementById("t3")
var t4 = document.getElementById("t4")
var p4 = document.getElementById("p4")
var freightSprite = document.getElementById("freightSprite")
//var t4 = document.getElementById("t4")
// Add new wall references:


var newPosX = 0
var newPosY = 0
var ukp = false
var collided=false
var speedDiff=0
var speed=0
var driving=true
var off=Math.PI*-2
var dkp = false
var gt=0
var heat=1
var rkp = false
var zd = false
var hunger = 1000000
var spin = 0
var lkp = false
var ox = 0
var oy = 0
var hoff=0
var ox3 = 0
var zoom=5
var colliding = false
var selectedTile = [0,0]
var oy3 = 0
var ox2 = 0
var sizeoff=1
var oy2 = 0
var cc = gFree
var boxTop = document.getElementById("BoxTop")
var boxSide = document.getElementById("BoxSide")
var mouseX; 
var mouseY; 
var mx = 0;
var my = 0;
var interacted=false
var smoothX = 0;
var smoothY = 0;
var cwidth=canvas.innerWidth
var cheight=canvas.innerHeight
var curr2
var xo
var drone = {x:50,y:0,t:0,w:32,h:32,r:0,hp:100}
var turnSpeed=0
var mode = "None"
var yo
var x
var y
var pmode=false
var ad=false
var trueTurn=0
var ed=false
var rd = false
var sx=0
var sy=0
var seconds=0
var qd=false
var prevDir=0
var alarmPlayed = false
var sky =document.getElementById("sky")
var dd=false
var GRID_SIZE = 32
const easingAmount = 0.05; 
canvas.width = window.innerWidth * 1
canvas.height = window.innerHeight * 1
var w = canvas.width;
var h = canvas.height;
const canvasCenterX = canvas.width / 2;
const canvasCenterY = canvas.height / 2;
function radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
}
function movedir(x,y,dir,amnt) {
return {x:(Math.sin((dir*-1) * Math.PI/180)*Math.round(amnt*100)/100),y:Math.cos((dir*-1) * Math.PI/180)}
}
function checkCircle(c1, c2) {
     dist = Math.hypot(c1.x - c2.x, c1.y - c2.y)

    minDist = (c1.r/3) + (c2.r/2)

    return dist <= minDist
}
var entities = [{x:75,y:97,w:150,h:150,sprite:p3,dist:9,type:"Planet",sx:0,sy:0,t:0,r:64,grav:100},{x:30000,y:97,w:10000,h:10000,sprite:p4,dist:1,type:"bigMan",sx:0,sy:0,t:0,r:10000/1.4,grav:1000},{x:10,y:30,w:64,h:64,sprite:rock1,dist:1,type:"Rok",sx:0,sy:0,t:0,r:64},
{x:0,y:0,w:32,h:32,sprite:rock1,dist:1,type:"astroid",t:0,sx:0,sy:0,r:32},{x:300,y:200,w:64,h:64,sprite:freightSprite,dist:1,type:"freighter",t:0,sx:0,sy:0,t:0,r:64}]
var usedPositions = [{x:stg(w / 2 ),y:stg(h / 2)}]
function getDist(x1,y1,x2,y2) {
//console.log(x2,x1)
    const deltaX = x2 - x1;
    const deltaY = y2 - y1;

    // Use the Pythagorean theorem: distance = sqrt((x2 - x1)^2 + (y2 - y1)^2)
    const distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));

    return distance;
}
document.addEventListener('mousemove', (event) => {
  mouseX = event.clientX;
  mouseY = event.clientY;
  mx = event.clientX;
  my = event.clientY;
});
function random(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function pointAt(startX, startY, targetX, targetY,o) {
if(!o){
o=0
}
return Math.atan2(startX-targetX,startY-targetY)+o
}
function calcDist(x1,y1,x2,y2) {
dx = x2 - x1
dy = y2 - y1
return Math.sqrt(dx * dx + dy * dy)
}

function smr32g() {
return random(-1,1) * 32

}
function diff(a,b) {
return(a-b)
}


function mr32g() {
return {x:smr32g(),y:smr32g()}
}
function collideCheck(s1, s2) {
//s1 should always be the player.
px=s1.x 
py=s1.y 
 
  if (px > s2.x-s2.w/2 && px < (s2.x+s2.w/2) && py > s2.y-s2.h/2 && py < (s2.y+s2.h/2) ){
		
    
	 // push the player back the targets width / 2
    return true;
  } else {

  return false;
}
}
 document.addEventListener('keyup', function(event) {
 kc = event.keyCode
 if (kc == 68) {

			dd=false
			
		  }
		  		  if (kc == 65) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ad=false
			
		  }
		  		  		  if (kc == 87) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			wd=false
			
		  }
		  		  		  		  if (kc == 83) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			sd=false
			
		  }
		  		  		  		  if (kc == 81) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			qd=false
			
		  }
		  	  		  		  if (kc == 69) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ed=false
			
		  }
		  	  		  	if (kc == 82) {

			rd=false
			
		  }
		  		  	  		  	if (kc == 79) {

			pd=false
			
		  }
		  		  	  		  	if (kc == 80) {

			od=false
			
		  }
		  		  		  		  		  		  if (kc == 90) {
			
			zd=false
			
		  }
		  		  		  		  	  		  	if (kc == 86) {

			bd=false
			
		  }
		  		  	  		  	if (kc == 84) {

			td=false
			
		  }
 })

    document.addEventListener('keydown', function(event) {
		interacted=true
       kc = event.keyCode
		  console.log(kc)

		  		  	if (kc == 68) {

			dd=true
			
		  }
		  	  		  	if (kc == 82) {

			rd=true
			
		  }
		  		  		  	  		  	if (kc == 79) {

			pd=true
			
		  }
		  		  	  		  	if (kc == 80) {

			od=true
			
		  }
		  		  		  	  		  	if (kc == 86) {

			bd=true
			
		  }
		  		  	  		  	if (kc == 84) {

			td=true
			
		  }
		  		
		  		
		  		  if (kc == 65) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ad=true
			
		  }
		  		  		  if (kc == 81) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			qd=true
			
		  }
		  	  		  		  if (kc == 69) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			ed=true
			
		  }
		  		  	  		  		  if (kc == 192) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			debug=!debug
			
		  }
		  		  if (kc == 70) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			mode="Feed"
			
		  }
		  		  		  		  if (kc == 87) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			wd=true
			
		  }
		  		  		  		  if (kc == 83) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			sd=true
			
		  }
		  		  		  		  		  if (kc == 83) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			sd=true
			
		  }
		  		  		  		  		  if (kc == 90) {
			//FEED HIM!!! DO IT FEED HIM NOW!!! FEED HIM!!!
			zd=true
			
			pmode=!pmode
		  }
		 
				

			
		  //try using list like mathematical thingys to sort distances
    });
	 var crashSpin=0
function tick() {
sky.style.backgroundPosition = `${-drone.x/10+hoff}px ${-drone.y/10+hoff}px`;
colliding=false
ticksUntilBoom-=1
if(ticksUntilBoom==0) {
	drone.x=50
drone.y=0
sx=0
sy=0
speed=0
drone.t=0
turnSpeed=0
trueTurn=0
alarmPlayed=false
drone.hp=100
audBoom.play()
audAlarm2.loop=false
}
//are we dying?
if(ticksUntilBoom>0) {
	turnSpeed+=crashSpin/2.5
	if(audAlarm2.loop==false) {
		audAlarm2.loop=true

audAlarm2.play()
	}

	ad=false
	dd=false
	wd=false
	sd=false
	qd=false
	ed=false
	
}
if(drone.hp<0&&ticksUntilBoom<0) {
//you fucking SUCK!!!! 
ticksUntilBoom=300
crashSpin=turnSpeed
}else{
				if (drone.hp<50&&alarmPlayed==false) {
						alarmPlayed=true
					audAlarm.play()
				
				
				}
			}
totalVelocity= Math.abs(sx+sy)
	 if (od) {
zoom=zoom*1.01
}
if (pd) {
zoom=zoom*0.99
}
zoom=Math.max(0,zoom)
	 ctx.save()
	  
	 ctx.translate(w/2,h/2)
    ctx.scale(zoom,zoom)
	 
	ox = drone.x - canvas.width / 2;
    oy = drone.y - canvas.height / 2;
seconds = Math.floor(gt/100)

    
	 
    setTimeout(() => { 
        ctx.clearRect(-100000,-100000,w*1000,h*1000)
		  const newPosX = ((smoothX - (w / 2)) * -0.025)/zoom
        const newPosY = ((smoothY - (h / 2)) * -0.04)/zoom
        ctx.save()
		  
			
		 	
		  	osx=sx
			osy=sy
		    for (i in entities) {
            curr = entities[i]
						
				ctx.save()


if (curr.type=="bigMan"){
curr.t+=0.01
//curr.sx=(Math.sin((curr.t/10) * Math.PI/-180))
//curr.sy=(Math.cos((curr.t/10) * Math.PI/-180))

gravDir=pointAt(drone.x,drone.y,curr.x,curr.y)
distance=getDist(drone.x,drone.y,curr.x,curr.y)
if (distance<curr.r*2.5) {
sx+=(Math.sin(gravDir)*(curr.grav)/(distance*-100))
sy+=(Math.cos(gravDir)*(curr.grav)/(distance*-100))
}
}
if (curr.type=="astroid"){
curr.t+=0.01

}
if (curr.type=="freighter") {
curr.sx=(Math.sin((curr.t) * Math.PI/-180))
curr.sy=(Math.cos((curr.t) * Math.PI/-180))

curr.t+=1
}
// runs every two ticks, please keep it this way or else there will be CATASTROPHIC concequences.
if(checkCircle(drone, curr)&&curr.dist==1&&collided==false){
//console.log("AGHH!!!!!")
colliding=true
collided=true

aDir=pointAt(curr.x,curr.y,drone.x,drone.y)+Math.PI*-1

prevDir=aDir
// do you know how fast you were going back there?
relativeSpeed = Math.abs((curr.sx+curr.sy)-(sx+sy))
console.log(relativeSpeed)
if(relativeSpeed>1){
drone.hp-=relativeSpeed*10
// this will not do anything unless we are actively in the middle of dying.
if(ticksUntilBoom>0){
console.log("you now have:",Math.max(0,ticksUntilBoom-(relativeSpeed*25)))
ticksUntilBoom=Math.max(0,ticksUntilBoom-(relativeSpeed*25))
}

}
drone.x=curr.x+(Math.sin((aDir)))*(curr.r/2)
drone.y=curr.y+(Math.cos((aDir)))*(curr.r/2)
//-drone.r/4

sx+=(Math.sin((aDir)))/5
sy+=(Math.cos((aDir)))/5
//+(Math.cos((aDir)))*(curr.r/2))/25
//add the turn into this please or else itll be occasionally wrong
turnDisruption=+(((Math.sin(aDir)-0.5)*2)+((Math.cos(aDir)-0.5)*-2))/10
//console.log(turnDisruption)
turnSpeed+=turnDisruption
//console.log(aDir,sx)
if (interacted) {
audImpact1.volume = Math.min(1,relativeSpeed/3)
audImpact1.play()
}


}



          curr.x+=curr.sx
			 curr.y+=curr.sy
			 ctx.translate((curr.x-drone.x)/curr.dist,(curr.y-drone.y)/curr.dist)
			 ctx.rotate(curr.t * Math.PI/180)
				//ctx.translate((curr.h/off),(curr.h/off))
			 

			   
				ctx.drawImage(curr.sprite,-curr.w/2,-curr.h/2,curr.w,curr.h)
				if(debug&&curr.dist==1){
				ctx.fillStyle="Red"
				ctx.lineWidth = 1;
				ctx.strokeStyle="Red"
				cwi=(curr.w)
				chi=(curr.h)
				cxi=curr.x-curr.w/2
				cyi=curr.y-curr.h/2
				ctx.beginPath()
				ctx.arc(0, 0, curr.r/2, 0, 2 * Math.PI, false);
				ctx.stroke()
				ctx.fill()
				ctx.closePath()
				
				//console.log((w/2)+(Math.sin((prevDir))))


				

				}		
if(colliding&&debug){
ctx.fillStyle="blue"
ctx.fillRect(-2,-2,4,4)
}
				ctx.restore()

				//console.log(Math.round(curr.x + drone.x),Math.round(curr.y + drone.y))
				
}
ctx.restore()
// Ensure 'random' is a defined function, e.g., using Math.floor(Math.random() * 101)
const rng = random(0, 10000); 
const GRID_SIZE = 32; // Define the grid size



	 		   



			  ctx.restore()
			  if(debug){
			ctx.fillStyle="Green"
ctx.fillRect((w/2)+(Math.sin((prevDir))*20)-5,(h/2)+(Math.cos((prevDir))*20)-5,10,10)
			
				ctx.fillStyle="Red"
				ctx.lineWidth = 1;
				ctx.strokeStyle="Red"

				ctx.beginPath()
				ctx.arc(w/2, h/2, drone.r, 0, 2 * Math.PI, false);
				ctx.stroke()
				ctx.fill()
				ctx.closePath()
			  }
            ctx.save()
        if (driving) {
		  if (dd) {
		               							if(pmode){
							sx+=0.001
							}else{
         turnSpeed+= 0.025+Math.abs(speed*2)
				}
				}
				if (qd) { 
sx=sx+ ((Math.sin(((trueTurn*-1)+90) * Math.PI/180))/175)
sy=sy+  ((Math.cos(((trueTurn*-1)+90) * Math.PI/180))/175)
				}
								if (ed) { 
sx=sx+ ((Math.sin(((trueTurn*-1)-90) * Math.PI/180))/175)
sy=sy+  ((Math.cos(((trueTurn*-1)-90) * Math.PI/180))/175)
				}
					   if (ad) {
						             							if(pmode){
							sx-=0.001
							}else{
             turnSpeed -= 0.025+Math.abs(speed*2)
				 }
				}
//					  if (zd) {
//		hoff+=0.1
//					  }
				 		   if (wd) {
              							if(pmode){
							sy-=0.001
							}else{
           speed=speed+0.00085
			  }
				}
							if (sd) {
							if(pmode){
							sy+=0.001
							}else{
           speed=speed-0.00085
			  }
				}
				if(rd) {
				//brakes, (slow the FUCK DOWN WE'RE GONNA CRASH!!!!!!!)
 speed=speed/1.0005
 //dir+awaydir/2 -- just curious what something like that would do, try something like that later.
 sx=sx/1.01
sy=sy/1.01
turnSpeed=turnSpeed/1.1
				} 
				 heat+= speed*1000
				 heat=(heat/1.01)-0.1
				 heat=Math.min(Math.max(1,heat),50)
				 turnSpeed=(turnSpeed)/1.02
			 	 speed=speed/1.1
				 trueTurn = trueTurn-(trueTurn-drone.t)/10
sx=sx+ (Math.sin((trueTurn*-1) * Math.PI/180)*Math.round(speed*100)/100)
sy=sy+  (Math.cos((trueTurn*-1) * Math.PI/180)*Math.round(speed*100)/100)
}
drone.t += turnSpeed
drone.x += sx
drone.y += sy

				
				//offsets=movedir(0,0,trueTurn,speed*100) 
offsets=[0,0]
				//console.log(offsets)
				ctx.translate(w/2-offsets[0], h/2-offsets[1]);
		
    ctx.scale(zoom/10,zoom/10)
ctx.rotate(trueTurn* (Math.PI/180))

    
    

				
				ctx.drawImage(dronesprite,-64,-64,128,128)
				sizeoff=random(0,4)
				sizeoff2=random(-1*(speed*1000)/8,1*(speed*1000)/8)
				audEngine.playbackRate = Math.abs(0.1+Math.ceil(speed*1000))
				if(speed<0.001) {
				timg=t1
				}
				if(speed>0.001) {
				timg=t2
				}
								if(speed>0.002) {
				timg=t3
				}
												if(speed>0.004) {
				timg=t4
				}

					//gah = 90-(Math.sin(gt/10))*-10
					gah = 50+Math.abs(heat)
				ctx.filter = `brightness(${gah}%)`
				ctx.drawImage(timg,-12+sizeoff2,-48-((speed*2000)+sizeoff),24,24+(speed*2000)+sizeoff)
				
				ctx.filter = ``
				ctx.restore();
				
		
//add induvisual systems control
			gt+=1
			//console.log(speedDiff)
			//making sure the cooldown is reset
			if (colliding){
			collided=true
			}else{
			collided=false
			}
			
			speedDiff=Math.abs((sx-osx)+(sy-osy))
        tick() 
    }, 10);
}
 function stg(thing) {
return Math.round(thing / 32) * 32
 }

tick(); 
</script>

</body>
</html>
